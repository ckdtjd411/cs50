3. 배열

1) 컴파일링
학습 목표 : 컴파일링의 네 단계를 설명할 수 있다.

[예시] hello.c
#include <stdio.h>

int main(void) 
{
	printf("hello, world!\n");
}

main 함수 : 프로그램의 시작점으로써 실행 버튼을 클릭하는 것과 같다.
printf는 출력을 담당하는 함수로 이를 사용하기 위해서는 stdio.h 라이브러리가 필요하다.

stdio.h는 헤더 파일로 C언어로 자겅되어 있으며 파일명이 .h로 끝나는 파일
이 파일에는 printf 함수의 프로토타입이 있어서 clang 컴파일러가 프로그램을 컴파일할때 printf가 무엇인지 알려주는 역할을 한다.

컴파일하면 어떤 일이 벌어질까?

함수 프로토타입을 사전에 정의해줘서 C에서 기본으로 제공하는 것보다 많은 함수를 사용할 수 있게 해준다.

#전처리(Precompile)
	전처리기에 의해 수행
	# 기호로 시작하는 C소스 코드는 전처리에게 실질적인 컴파일이 이루어지기 전에 무언가를 실행하라고 알려준다.
	#include는 전처리기에게 다른 파일의 내용을 포함시키라고 알려준다.
	전처리기는 새로운 파일을 생성하는데 이 파일은 여전히 C 소스 코드 형태이며 헤더파일에 직접 찾아가 해당되는 코드를 가져와서 소스코드에 붙여놓는다.

#컴파일(Compile)
	컴파일러는 소스 코드를 어셈블리어라는 저수준 프로그래밍 언어로 컴파일한다.
	어셈블리는 C보다 연산의 종류가 훨씬 적지만, 여러 연산들이 함께 사용되면 C에서 할 수 있는 모든 것들을 수행할 수 있다.
	c로 작성된 소스 코드는 어셈블리 코드라는 중간 코드로 바뀌고 CPU가 실제로 이해할 수 있는 언어와 최대한 가까운 프로그램으로 만든다.
	컴파일이라는 용어는 소스 코드에서 오브젝트 코드로 변환하는 전체 과정을 통틀어 일컫기도 하지만, 구체적으로 전처리한 소스 코드를 어셈블리 코드로 변환시키는 단계를 말하기도 한다.
	cpu가 실제로 이해하는 건 아주 기초적인 수준의 명령어들.
	
#어셈블(Assembling)
	어셈블리 코드를 오브젝트 코드로 변환시키는 것
	CPU가 프로그램을 어떻게 수행해야 하는지 알 수 있는 명령어 형태인 연속된 0과 1들로 바꿔주는 작업
	이 변환작업은 어셈블러라는 프로그램이 수행
	소스 코드에서 오브젝트 코드로 컴파일 되어야 할 파일이 닥 한 개라면, 컴파일 작업은 여기서 끝난다.
	그렇지 않은 경우에는 링크 단계가 추가된다.

#링크(link)
	프로그램이 여러 개의 파일로 이루어져 있어 하나의 오브젝트 파일로 합쳐져야 한다면 링크 단계가 필요
	링커는 여러 개의 다른 오브젝트 코드 파일을 실행 가능한 하나의 오브젝트 코드 파일로 합쳐준다.
	컴파일을 하는 동안에 CS50 라이브러리를 링크하면 오브젝트 코드는 getString() 같은 함수를 어떻게 실행할 지 알 수 있게 한다.

이렇게 네 단계를 거치면 최종적으로 실행 가능한 파일이 완성된다.

#생각해보기
Q : 만약 컴파일링 과정을 거치지 않기 위해 바로 머신코드로 우리가 원하는 프로그램을 작성하려고 한다면 어떤 문제가 있을까요?
A : 모든 명령어와 숫자를 0과 1로 조합된 비트열을 암기하거나 방대한 자료를 가지고 있어야 한다.
	머신 코드를 보고 프로그램이 어떻게 작동하는지 유추하기 힘들다.


2) 디버깅
학습 목표 : 디버깅 하는 여러 방법을 설명할 수 있다.

#버그와 디버깅
	버그는 의도하지 않은 프로그램 내 오류
	버그로 인해 프로그램의 실행에 실패하거나 프로그래머가 원하는 대로 동작하지 않게 된다.
	디버깅(Debugging)은 코드에 있는 버그를 식별하고 고치는 과정
	프로그래머는 디버거라고 불리는 프로그램을 사용하여 디버깅을 하게 된다.

#디버깅의 기본
	프로그램은 일반적으로 인간보다 훨씬 빠르게 연산을 수행한다.
	그래서 프로그램을 실행시켜보는 것만으로는 오류를 찾아내기 어렵다.
	디버거는 프로그램을 특정 행에서 멈출 수 있게 해주기 때문에 버그를 찾는데 도움이 된다.
	프로그램이 멈추는 특정 지점을 중지점(break point)라고 하며 프로그램을 한번에 한 행씩 실행할 수 있게 해준다.
	컴퓨터의 메모리 안에서 벌어지는 일을 프로그램 실행중에 알 수 있게 해준다.
	
#help50
	오류 메시지 중 이해할 수 있는 내용을 노란색으로 강조
	명령어를 실행하여 문제가 발생할 때 help50을 붙여서 실행하면 생기는 오류를 해석해준다.

#printf
	잘못된 기호나 명령어를 입력해서 문법적으로 나타나는 버그가 아닌 논리적 오류를 찾을 때 사용

#debug50
	CS50 IDE를 사용하면 debug50이라는 프로그램도 사용할 수 있다.
	소스 코드에 블이크포인트를 지정하고 소스파일을 컴파일한 후에 "debug50 파일명"으로 실행면,
		오른쪽 패널을 통해 변수의 값을 확인하거나 브레이크포인트로부터 한 줄씩 코드를 실행해 볼 수 있다.
	디버깅 종료를 위해서는 Ctrl + C

#생각해보기
Q : 디버깅을 도와주는 프로그램은 어떤 경우에 더 큰 도움이 될까? 만약 이런 프로그램의 도움 없이 직접 디버깅을 해야한다면 어떻게 코드를 작성하는 것이 좋을까?
A : 코드의 양이 많아서 일일이 확인하기 어려운 경우
	주석을 달아서 그룹별로 구분해서 코드를 작성한다.


3) 코드의 디자인
학습 목표 : 코드의 정확성과 디자인을 관리하는 방법을 설명할 수 있다.

#check50
	코드의 정확도를 분석해주는 도구
	이를 활용하면 과제를 잘 수행했는지 자동으로 검사할 수 있다.

#style50
	코드가 심미적으로 잘 작성되어 있는지 검사
	코드를 작성 시에는 자신과 다른 사람들이 읽기 쉽도록 무엇보다 유지보수하기 쉽도록 작성해야 한다.
	
좋은 디자인의 소프트웨어를 작성하고 문제를 잘 해결할 수 있도록 좋은 결정을 내리는 과정
	
이 도구들은 모두 정확한 코드 작성과 연관되어 있다.
원하는 대로 작동하며 주어진 문제를 해결하는 코드를 짜기 위한 도구
	
#고무 오리(러버덕 디버깅)
	코드에 포함된 오류를 해결할 때 앞의 프로그램들이 존재하지 않거나, 있다 하더라도 디버깅에 큰 도움이 안 될 수도 있다.
	이 때는 먼저 한숨 돌리고 직접 곰곰히 생각해보는 수 밖에 없다.
	'고무 오리'와 같이 무언가 대상이 되는 물체를 앞에 두고, 작성한 코드를 한 줄 한 줄 설명해주는 과정을 통해 놓치고 있던 논리적 오류를 찾아낼 수도 있다.
	문제를 해결하는 데 있어 도구 의존도를 줄이고 다시 집중하는 매커니즘

#생각해보기
Q : 만약 여러 사람들이 함께 참여하는 프로젝트에서, 각자가 작성하는 코드 스타일이 서로 다르다면 어떤 비효율적인 일이 발생할까?
A : 
	

4) 배열(1)
학습 목표 : 배열을 정의하고 사용하는 방법을 설명할 수 있다.

#메모리
	C에는 아래와 같은 여러 자료형이 있고, 각각의 자료형은 서로 다른 크기의 메모리를 차지한다.
	• bool: 불리언, 1바이트
	• char: 문자, 1바이트
	• int: 정수, 4바이트
	• float: 실수, 4바이트
	• long: (더 큰) 정수, 8바이트
	• double: (더 큰) 실수, 8바이트
	• string: 문자열, ?바이트

	컴퓨터 메모리에 있는 모든 변수들은 이와 같은 자료형을 가지고 있다.
	컴퓨터 안에는 RAM 이라고 하는 물리적 칩이 메모리 역할을 한다.
	소프트웨어 구동 시에 정보가 저장되는 곳, 여러 바이트들의 묶음이라고 생각할 수 있다.
	
	C에서 char를 입력할 때는 '' 작은따옴표가 필요
	ASCII와 유니코드로 문자를 숫자로 변환한 것
	
	형변환 : 하나의 자료형을 다른 종류로 바꾸는 행위
	추상화라는 개념 덕분에 복잡한 것들은 무시하고 더 높은 수준의 정보를 다룰 수 있다.
	
	같은 일을 계속해서 반복하는 건 디자인 개선의 여지가 있다는 것

#배열
	변수의 개수가 많아진다면 프로그램 수정 시 많은 부분을 수정해줘야 한다.
	하나 이상의 값들이 서로 연관되어 있다고 할 때 여러 개의 값을 가진 하나의 변수로 관리하기 위해 사용한다.
	int scores[3];
		int 자료형을 가지는 크기 3의 배열을 scores 라는 이름으로 생성하겠다는 의미
	이 인덱스를 변수명 뒤 대괄호 [] 사이에 입력하여 배열의 원하는 위치에 원하는 값을 저장하고 불러올 수 있다.
	배열의 인덱스는 0부터 시작한다.

#생각해보기
Q : 실생활의 어떤 데이터를 배열로 표현할 수 있을까?
A : 삼성 갤럭시 시리즈의 종류
	string samsung_galuxy[10] = {"galuxy S1", ... ,"galuxy S20"}


5) 배열(2)
학습 목표 : 배열을 정의하고 사용하는 방법을 설명할 수 있다.

#전역 변수
	어떤 변수에 특정 값을 지정할 때 그 값을 바꾸고 싶지 않다면 그 값을 선언할 때 const를 붙여서 전역 변수,
	 코드 전반에 거쳐 바뀌지 않는 값임을 지정해 줄 수 있다.
	해당 변수를 상수로 지정하면 컴파일러가 그 값을 바꾸지 않도록 해준다.
	관례적으로 이런 전역 변수의 이름은 대문자로 표기한다.

#배열의 동적 선언 및 저장
	// 사용자로부터 점수의 갯수 입력
    int n = get_int("Scores:  ");

    // 점수 배열 선언 및 사용자로부터 값 입력
    int scores[n];
    for (int i = 0; i < n; i++)
    {
        scores[i] = get_int("Score %i: ", i + 1);
    }
	
	배열의 크기를 사용자에게 직접 입력 받고, 배열의 크기만큼 루프를 돌면서 각 인덱스에 해당하는 값을 역시 입력 받아 저장한다.
	
	//평균을 계산하는 함수
	float average(int length, int array[])
	{
		int sum = 0;
		for (int i = 0; i < length; i++)
		{
			sum += array[i];
		}
		return (float) sum / (float) length;
	}
	
	average 함수는 length 와 array[], 즉 배열의 길이와 배열을 입력으로 받는다.
	함수 안에서는 배열의 길이만큼 루프를 돌면서 값의 합을 구하고 최종적으로 평균값을 반환한다.
	반환값은 함수가 사용자에게 돌려주는 값, 함수명 앞의 자료형에 따라 결정
	정수를 정수로 나누면 소수점 뒤 숫자들은 모두 버려지고 정수로 출력된다.
	이 때문에 형변환을 이용해 float로 자료형을 변경해서 계산한다.

#생각해보기
Q : 점수의 평균을 구하는 예제에서, 동적으로 작성한 코드는 그렇지 않은 코드에 비해 어떤 장단점이 있을까?
A : 코드를 수정하거나 매번 값이 바뀌는 경우에 사용하기에 좋다.
	반면 고정된 값의 평균을 구하는 프로그램이라면 매번 입력해야 하는 번거로움이 있다.


6) 문자열과 배열
학습 목표 : 문자열이 C에서 정의되는 방식과 메모리에 저장되는 방식을 설명할 수 있다.

배열을 활용해서 디자인을 개선하고 여러 값들을 하나의 변수에 저장해서 복사 붙여넣기 문제를 방지했다.
실제로 메모리 안에서 일어나는 일도 이와 크게 다르지 않다.

문자열(string) 자료형의 데이터는 문자(char) 자료형의 배열
여러 개의 문자들을 저장하는 것이 각 변수마다 하나의 문자를 저장하는 것보다 유용하기 때문

string은 글자 수만큼 바이트가 필요, 정해진 크기를 알 수 없다.
변수의 이름은 시작점에 대한 정보를 알려준다.
프로그램 내에 s라는 변수를 만들면 컴퓨터는 해당 문자열의 첫 번째 글자를 가리킨다.

\0 : 널 문자 혹은 널 종단 문자
	 문자열이 언제 끝나는지를 알려주는 정보
	 문자열의 끝을 나타내며 모든 비트가 0인 1바이트를 의미한다.
입력한 문자열들은 모두 글자수 + 1 바이트만큼의 공간을 차지한다.

문자열은 2차원 배열을 통해 각 문자에 접근할 수 있다.
첫 번째는 이름들의 배열의 인덱스를 나타낸다. 배열의 인덱스는 어떤 배열의 특정 위치
두 번째는 이름을 문자들의 배열로 보고 그 중 n번째 위치를 뜻한다.
즉, names[0][1]은 names[0]의 첫 번째 값의 그 두번째 값을 의미.

#생각해보기
Q : 널 종단 문자는 왜 필요할까?
A : 문자열의 경우 문자가 언제 끝나는지 알 수 없으므로 


7) 문자열의 활용
학습 목표 : 문자열을 탐색하고 일부 문자를 수정하는 코드를 구현할 수 있다.

#문자열의 길이 및 탐색
	문자열의 끝을 알 수 있는 방법
	• 인덱스의 문자가 널 문자와 일치하는지 검사
		s라는 문자열이 있다고 할 때 s[i] != '\0'
	• strlen 함수 사용
		문자열의 길이를 알려주는 함수
		string.h 라이브러리 안에 포함되어 있다. (문자열과 연관된 다양한 함수들이 있는 라이브러리)

	조건문은 질문을 나타내는 불리언 표현으로 함수를 호출하는 건 시간이 걸린다
	컴퓨터가 매우 빠르더라도같은 질문을 계속해서 반복해야 할 필요가 없다.
	문자열의 길이는 변하지 않으므로 이를 변수에 저장하여 사용한다.

#문자열 탐색 및 수정
	s[i] >= 'a' && s[i] <= 'z'
	각 인덱스에 해당하는 문자가 'a'보다 크고 'z'보다 작은지 검사.
	즉, 소문자인지 검사하는 것과 동일
	
	문자의 대소비교가 가능한 이유는 ASCII 값, 즉 그 문자가 정의되는 ASCII 코드 상에서의 숫자값으로 비교할 수 있기 때문
	A : 65, a : 97
	대문자와 소문자는 32씩 차이가 난다.
	
	ctype 라이브러리에 toupper 함수를 사용하면 대문자 변환을 쉽게 할 수 있다.

#생각해보기
문서에서 중요한 부분은 필수 헤더 파일과 프로토타입
Q : string.h와 ctype.h의 라이브러리에 다른 어떤 함수가 있는지 확인해 보고, 어떤 함수를 어떻게 활용해 볼 수 있을지 생각
A : string.h [ strlen, strcmp, strchr, ... ]
	ctype.h  [ isalpha, islower, isdigit, ... ]


8) 명령행 인자
학습 목표 : 명령행 인자를 받는 프로그램을 C로 작성할 수 있다.

#명령행 인자
clang은 기본적으로 a.out이라는 파일을 출력했는데 -o hello와 같은 명령어를 추가하면 원하는 파일로 출력을 바꿀 수 있었다.
명령어 뒤에 쓰고 프로그램의 입력과 같이 넣어주는 인자로 실행하고자 하는 프로그램 뒤에 적는다.

int main(int argc, string argv[])
첫 번째 변수 argc는 main 함수가 받게 될 입력의 개수
argv[]는 그 입력이 포함되어 있는 배열, 프로그램을 명령형에서 실행하므로, 입력믄 문자열로 주어진다.
따라서 argv[]는 string 배열

사용자에게 입력을 받을 때 string 대신 실제 명령 프롬프트로 받을 수 있다.

argv[0]은 기본적으로 프로그램의 이름이 저장된다.
하나의 입력이 더 주어진다면 argv[1]에 저장

if (argc == 2)
	사용자가 프롬프트에 단어 2개를 입력했다는 뜻

main 함수는 반환값이 왜 있는가?
C의 main함수는 기본적을 반환값을 가진다.
main가 오류 없이 실행을 마치면 0을 반환한다.

#생각해보기
Q : 명령행 인자는 프로그램의 확장성에 어떤 도움이 될까? 구체적인 예시.
A : 사용자의 입력을 유연하게 받을 수 있다.
	고객센터에 전화할 때 1번은 A/S 2번은 요금제 변경과 같이 되어있을 때 2번을 입력하고
	더 세부적으로 전문가와의 상담을 원하면 1번, 전화를 통한 변경은 2번 이런식으로 사용자의 유연한 입력을 받을 수 있다.