4. 알고리즘

1) 검색 알고리즘
학습 목표 : 주어진 배열 속에서 특정 값을 찾는 방법을 설명할 수 있다.

배열은 한 자료형의 여러 값들이 메모리상에 모여 있는 구조
컴퓨터는 이 값들에 접근할 때 배열의 인덱스 하나하나를 접근
메모리를 바이트의 격자 배열로 취급하면 원하는 대로 사용가능하다.
컴퓨터는 전체를 한번에 접근할 수 없으므로 배열 속 요소를 하나하나 봐야한다.

#선형 검색
배열의 인덱스를 처음부터 끝까지 하나씩 증가시키면서 방문하여 그 값이 속하는지 검사
정렬되어 있는지 알지 못하는 상황에서는 하나하나 확인해보아야 한다.

[Pseudo Code]
for i from 0 to n-1
	if 1'th element is 50
		Return true
Return False

#이진 검색
배열이 정렬되어 있다면, 배열 중간 인덱스부터 시작하여 찾고자 하는 값과 비교하며 그보다 작은(작은 값이 저장되어 있는) 인덱스
또는 큰(큰 값이 저장되어 있는) 인덱스로 이동을 반복하면 된다.

[Pseudo Code]
if no items
	Return false
if middle item is 50
	Return true
Else if 50 < middle item
	Search left half
Else if 50 > middle item
	Search right half

#생각해보기
Q : 만약 정렬되지 않은 배열이 있다면, 선형 검색이 빠를까 이진 검색이 빠를까?
A : 모든 배열의 요소를 탐색하는 올바른 알고리즘이라고 했을 때, 선형 검색이 더 빠를 것이다.
	정렬되지 않은 배열에 대해서 이진 검색을 사용한다면 중간값을 기준으로 탐색하는 것이 무의미하기 때문에
	계속해서 새로운 중간값을 설정해서 반복실행해야 할 것이다.
	이에 비해 선형 검색은 처음부터 끝까지 순차적으로 실행하기 때문에 선형검색이 더 속도가 빠를것이다.


2) 알고리즘 표기법
학습 목표 : 알고리즘의 실행 시간의 상한과 하한을 표기할 수 있다.

간단한 프로그램인 경우에는 실행 시간을 걱정할 필요가 없지만, 처리하는 데이터가 많아지고 처리하는 작업이 복잡해질수록 실행 시간은 매우 중요해진다.
알고리즘은 직선으로 그려지는 선형의 형태이거나 좀 더 굴곡이 있거나 로그 형태일 수도 있다.

알고리즘을 설명하기 위해 특정 용어를 사용한다.
알고리즘이 얼마나 잘 설계되어 있는지 또 코드가 얼마나 잘 구현되어 있는지를 나타내기 위해
알고리즘이나 코드가 주어지는 입력값에 따라 얼마나 좋은지 파악할 수 있는 척도

#Big O 표기법
O는 "on the order of"의 약자로, 쉽게 생각하면 "~만큼의 정도로 커지는" 것이라고 볼 수 있다.
알고리즘이 얼마나 효율적인지 물어본다면 즉 코드의 효율성을 묻는다면 Big O 표기법을 사용
대략적인 추정값을 표현하는 것, 실행 시간을 나타내기 위해 많이 사용한다.

	• O(n^2)
	• O(n log n)
	• O(n) - 선형 검색
	• O(log n) - 이진 검색
	• O(1)

O(n)은 n만큼 커지는 것이므로 n이 늘어날수록 선형적으로 증가하게 된다.
O(n/2)도 결국 n이 매우 커지면 1/2은 큰 의미가 없어지므로 O(n)이라고 볼 수 있다.

실행 시간이란 프로그램이나 알고리즘이 동작하는 데 걸리는 시간
몇 초 혹은 몇 번의 계산 과정이 필요한지.

#Big Ω 표기법
Big-O는 알고리즘을 수행하는 데 필요한 시간의 상한선을 의미
Big-Ω는 알고리즘 실행 시간의 하한을 의미

Ω (Omega) 
Omega를 사용하면 최상의 경우를 나타낼 수 있다.
선형 검색을 할 떄 최악의 경우 n번 또는 7번의 과정이 필요, 최선의 경우에는 1번
따라서 Big-O는 O(n), Big-Ω는 Ω(1)

	• Ω(n^2)
	• Ω(n log n)
	• Ω(n) - 배열 안에 존재하는 값의 개수 세기
	• Ω(log n)
	• Ω(1) - 선형 검색, 이진 검색

Omega값과 Big-O값 중 어느 것이 좋아야 좋은 알고리즘인가?
Big-O, 프로그래머가 걱정하는 것은 최악의 경우에 프로그램이 어떻게 동작할지 또는 평균적으로 어떻게 동작하는지 

#생각해보기
Q : 실행시간의 상한이 낮은 알고리즘이 더 좋을까 하한이 낮은 알고리즘이 더 좋을까
A : 상한이 낮은 알고리즘이 더 좋다.
	최선의 경우로 실행되는 입력보다 최악의 경우를 고려하여 점차 실행시간을 줄여서 평균 시간을 낮추는 것이 더 좋을 것

3) 선형 검색
학습 목표 : 주어진 배열 또는 구조체에서 선형 검색을 할 수 있다.

#선형 검색
찾고자 하는 자료를 검색하는 데 사용되는 다양한 알고리즘 그 중 하나가 선형 검색.
선형 검색은 원하는 원소가 발견될 때까지 처음부터 마지막 자료까지 차례대로 검색한다.
이렇게 하여 선형 검색은 찾고자 하는 자료를 찾을 때까지 모든 자료를 확인해야 한다.

#효율성 그리고 비효율성
선형 검색 알고리즘은 정확하지만 아주 효율적이지 못한 방법
리스트 길이가 n이라고 했을 떄, 최악의 경우 리스트의 모든 원소를 확인해야 하므로 n번만큼 실행된다.
최악의 상황은 찾고자 하는 자료가 맨 마지막에 있거나 리스트 안에 없는 경우
반대로 최선의 상황은 처음 시도했을 때 찾고자 하는 값이 있는 경우
평균적으로 선형 검색이 최악의 상황에서 종료되는 것에 가깝다고 가정.
선형 검색은 자료가 '정렬되어 있지 않거나 그 어떤 정보도 없어 하나씩 찾아야 하는 경우에 유용'하다.
이 때문에 검색 이전에 정렬을 해야 한다. 
정렬은 시간이 오래 걸리고 공간을 더 차지하지만 여러 번 리스트를 검색해야 하거나 매우 큰 리스트를 검색할 때 시간을 단축할 수 있다.

• 배열에서 특정 값을 찾기 위해 선형 검색을 사용한 경우
	#include <cs50.h>
	#include <stdio.h>
	#include <string.h>

	int main(void)
	{
		string names[] = {"EMMA", "RODRIGO", "BRIAN", "DAVID"};
		string numbers[] = {"617–555–0100", "617–555–0101", "617–555–0102", "617–555–0103"};

		for (int i = 0; i < 4; i++)
		{
			if (strcmp(names[i], "EMMA") == 0)
			{
				printf("Found %s\n", numbers[i]);
				return 0;
			}
		}
		printf("Not found\n");
		return 1;
	}
배열의 크기만큼 for 루프를 돌면서 배열의 인덱스를 차례대로 방문하며 찾는 값이 있는지를 검사
names[i] == "EMMA"로 사용할 수 없는 이유
	자료형이 다르다.
	관계연산자 ==는 문자열에 사용할 수 없다.
	문자열 자체가 배열로 여러 개의 문자로 구성된다.
	두 문자열을 비교하고 싶다면 문자열 속에 문자를 하나씩 비교해야 한다.
	C 언어는 모든 것이 로우 레벨로 진행

문자열 비교하는 함수 strcmp 
strcmp 함수는 두 문자열이 같다면 0을 반환 
양수를 반환하면 첫 번째 문자열이 알파벳 기준으로 큰 경우이고 음수면 반대의 경우

결과가 성공적이었다고 알려주기 위해 일반저긍로는 0을 반환, 성공적이지 않았다면 1을 반환
숫자 자체에는 큰 의미는 없지만 관습

전화번호를 문자열로 쓰는 이유?
	전화번호에는 -나 괄호도 있고 해외번호는 +기호도 있다.
	사실 숫자가 아니라 숫자를 나타내는 문자로 사용
	0부터 누르게 되는데 수학에서 맨 앞의 0은 생략되어 버린다.


위의 코드는 names 배열과 numbers 배열이 서로 같은 인덱스를 가져야 한다는 한계가 존재
더 좋은 방법은 새로운 자료형으로 구조체를 정의해서 이름과 번호를 묶어주는 것

#typedef 
typedef 새로운 타입을 정의한다.
구조체(struct)는 c에 미리 정의된 키워드로 마치 그릇처럼 여러 가지 자료형을 담을 수 있다.
컴파일러에게 새로운 자료형이 있다고 알려줄 수 있다.

	typedef struct
	{
		string name;
		string number;
	}
	person;

person이라는 이름의 구조체를 자료형으로 정의하고 person 자료형의 배열을 선언하면 
그 안에 포함된 속성값은 '.'으로 연결해서 접근할 수 있다.
이름과 번호의 관계는 그대로 유지

모든 정보를 한 번에 묶어서 표현할 수 있다.
캡슐화하여 많은 관련 정보를 한 번에 관리할 일이 많다.

#생각해보기
Q : 전화번호부와 같이 구조체를 정의하여 관리 및 검색을 하면 더 편리한 예는 또 무엇이 있을까?
A : 학생의 개인정보를 기록하는 경우.
	이름, 학번, 생년월일, 학과 등 같이 묶어서 저장하면 관리하기 편할 것


4) 버블 정렬
학습 목표 : 버블 정렬의 원리와 실행 시간을 설명하고 구현할 수 있다.

#버블 정렬
정렬되지 않은 리스트를 탐색하는 것보다 정렬한 뒤 탐색하는 것이 더 효율적
버블 정렬은 두 개의 인접한 자료 값을 비교하면서 위치를 교환하는 방식으로 정렬하는 방법
버블 정렬은 단 두 개의 요소만 정렬해주는 좁은 범위의 정렬에 집중한다.
간단하지만 단 하나의 요소를 정렬하기 위해 너무 많이 교환하는 낭비가 발생할 수도 있다.

거품이(비교 및 교환이) 터지면서 위로 올라오는 (배열의 옆으로 이동하는) 방식이기 때문

[Pseudo Code]
Repeat n-1 items
	For i from 0 to n-2
		If i'th and i+1'th elements out of order
			Swap them

중첩 루프를 돌아야 하고, n개의 값이 주어졌을 때 각 루프는 n-1번, n-2번 반복된다.
따라서 (n - 1) * (n - 2) = n^2 - 3n + 2번의 비교 및 교환이 필요
가장 크기가 큰 요소는 n^2이므로 버블 정렬 실행 시간의 상한은 O(n^2)

버블 정렬을 사용하면 선형 탐색이나 이진 탐색보다 더 시간이 많이 든다.
그러나, 이진 탐색은 이미 정렬된 배열에 대한 탐색이므로 정렬 알고리즘에 따라 다를 수 있다.
상황에 따라 배열에 대해 여러 번 탐색을 해야 하는 경우라면 한 번 정렬을 해두는 것이 좋다.

이미 정렬되어 있어도 n-1번 반복하고 내부에서도 n-2번 반복
이미 정렬된 배열이 들어와도 n^2

#생각해보기
Q : 버블 정렬이 효율적인 경우는 어떤 경우? 반대로 어떤 경우에 비효율적인가?
A : n의 개수가 작을 때 효율적, n의 개수가 커질수록 비효율적


5) 선택 정렬
학습 목표 : 선택 정렬의 원리와 실행 시간을 설명하고 구현할 수 있다.

#선택 정렬
배열 안의 자료 중 가장 작은 수(혹은 가장 큰 수)를 찾아 첫 번째 위치(혹은 가장 마지막 위치)의 수와 교환해주는 방식의 정렬
선택 정렬은 교환 횟수를 최소화하는 반면 각 자료를 비교하는 횟수는 증가한다.

[Pseudo Code]
For i from 0 to n-1
	Find smallest item between i'th item and last item
	Swap smallest item with i'th item

O(n + n-1 + n-2 + n-3 + .... + 1)
O(n(n+1)/2) = O(n^2)
n이 커질수록 점점 빠르게 커져서 가장 빠르게 증가한다
선택 정렬 또한 O(n^2) 알고리즘

다른 수에 대한 정보가 없기 때문에 배열 속 다른 값을 전부 보기 전까지는 가장 작은 값인지 알 수 없다.
즉 선택 정렬을 사용해도 앞에 놓인 수만 알 수 있기 때문에 같은 코드를 반복할 것이다.
최선의 경우와 최악의 경우가 동일.
Ω(n^2)

#생각해보기
Q : 선택정렬을 좀 더 효율적으로 어떻게 바꿀 수 있을까?
A : 가장 작은 값을 저장하기 전에 가지고 있던 배열의 값의 인덱스를 기억해 두었다가 다음 탐색을 수행할 때 교환한다.


6) 정렬 알고리즘의 실행시간
학습 목표 : 여러 정렬 알고리즘과 검색 알고리즘의 실행 시간을 Big-O와 Big-Ω로 정의할 수 있다.

#실행시간의 상한
	• O(n^2): 선택 정렬, 버블 정렬
	• O(n log n)
	• O(n): 선형 검색
	• O(log n): 이진 검색
	• O(1)

#실행시간의 하한
	• Ω(n^2): 선택 정렬, 버블 정렬
	• Ω(n log n)
	• Ω(n)
	• Ω(log n)
	• Ω(1): 선형 검색, 이진 검색

버블 정렬은 인접한 항목들의 위치를 바꾼다.계속 반복해서 모든 게 정렬될 때까지.

알고리즘을 멈추거나 줄이는 조건문이 있으면 시간을 단축할 수 있다.
교환이 없을 때까지만 반복하도록 바꾸면 효율적

버블 정렬이라는 이름처럼 가장 큰 항목이 끝까지 떠올라간다.
작은 값도 조금씩 왼쪽으로 움직인다.

선택 정렬은 가장 작은 값을 찾아내 가장 왼쪽으로 옮긴다.
버블 정렬은 큰 값이 오른쪽, 선택 정렬은 가장 작은 값이 왼쪽

만약 정렬이 모두 되어 있는 숫자 리스트가 주어진다면 교환이 하나도 일어나지 않을 것이다.
따라서 버블 정렬의 바깥쪽 루프를 '교환이 일어나지 않을때'까지만 수행하도록 바꿀 수 있다.

[Pseudo Code - 개선된 버블정렬]
Repeat until no swaps
    For i from 0 to n–2
        If i'th and i+1'th elements out of order
            Swap them

따라서 최종적으로 버블 정렬의 하한은 Ω(n)이 된다.

#생각해보기
Q : 선택 정렬의 실행 시간의 하한도 버블 정렬처럼 더 단축시킬 수 있을까?
A : 선택정렬은 비교에서 O(n^2)의 복잡도를 가지므로 단축되지 않을 것 같다.


7) 재귀
학습 목표 : 함수를 재귀적으로 사용하는 코드를 작성할 수 있다.

#재귀
함수를 사용할 대 main 안에서 프로그램을 작성하면서 필요한 순간에 호출하여 사용한다.
main 역시 함수이므로 main이라는 함수 안에서 도 다른 함수를 사용한 것
함수가 본인 스스로를 호출해서 사용하는 것 이를 재귀(Recursion)라고 부른다.
 
단순히 같은 것을 반복 시키는 것이 아니라 알고리즘 다음 단계에서의 문제의 크기를 계속 절반으로 줄여나가는 것
프로그램이나 알고리즘이 스스로를 계속 호출하는 것
시작점의 조건문이 끊임없이 반복하는 것을 막아주고 재귀적으로 스스로를 호출하면서 기존 문제보다 더 작은 크기의 문제를 풀어간다.

재귀 함수는 내부에서 자기 자신을 호출한다.
재귀적 정의 : 눈에 보이는 혹은 가상의 물체의 구조를 그 자체를 이용해서 설명하는 것

• 재귀로 피라미드 모양 출력하기
int main(void)
{
    int height = get_int("Height: ");
    draw(height)
}

void draw(int h)
{
    if (h == 0)
    {
        return;
    }

    draw(h - 1);

    for (int i = 0; i < h; i++)
    {
        printf("#");
    }
    printf("\n");
}

h라는 높이를 받았을 때, h-1 높이로 draw 함수를 먼저 호출하고, 그 후에 h 만큼의 #을 출력
여기서 내부적으로 호출된 draw 함수를 따라가다 보면 h = 0인 상황이 오게 된다.
따라서 그 때는 아무것도 출력을 하지 않도록 하는 조건문을 추가해줘야 한다.
재귀를 사용하면 중첩 루프를 사용하지 않고도 하나의 함수로 동일한 작업을 수행할 수 있다.

#생각해보기
Q : 반복문을 쓸 수 있는데도 재귀를 사용하는 이유는 무엇일까?
A : 피라미드 출력하기처럼 반복문을 사용할 경우 중첩 루프를 사용하여 실행 시간의 상한이 O(n^2)이 된다.
	재귀를 사용하면 중첩 루프를 사용하지 않고 하나의 루프만 사용하므로 실행 시간의 상한이 O(n)이 된다.
	실행 시간이 매우 단축되는 것을 볼 수 있다.


8) 병합 정렬
학습 목표 : 재귀를 활용한 병합 정렬을 구현할 수 있다.

#병합 정렬
원소가 한 개가 될 때까지 계속해서 반으로 나누다가 다시 합쳐나가며 정렬을 하는 방식
이 과정은 재귀적으로 구현된다.

예시) 
오름차순 정렬
	7 4 5 2 6 3 8 1
	
	먼저 숫자들을 반으로 나눈다.
	7 4 5 2 | 6 3 8 1
	
	그리고 나눠진 부분 중 첫번째를 한번 더 반으로 나눈다.
	7 4 | 5 2 | 6 3 8 1
	
	마지막으로 한 번 더 나눈다.
	7 | 4 | 5 2 | 6 3 8 1
	
	이제 숫자가 두 개 밖에 남지 않았으므로 더 이상 나누지 않고, 두 숫자를 다시 병합한다.
	단, 이때 작은 숫자가 먼저 오도록 한다.
	4 7 | 5 2 | 6 3 8 1
	
	마찬가지로 5 2 부분도 반으로 나눈 후에 작은 숫자가 먼저 오도록 다시 병합
	4 7 | 2 5 | 6 3 8 1

	이제 4 7과 2 5 두 개의 부분들을 병합
	각 부분들의 숫자들을 앞에서 부터 순서대로 읽어들여 비교하여 더 작은 숫자를 병합되는 부분에 가져온다.
	2 4 5 7 | 6 3 8 1
	
	오른쪽 4개의 숫자들도 위와 동일한 과정을 거친다.
	2 4 5 7 | 1 3 6 8
	
	마지막으로 각각 정렬된 왼쪽 4개와 오른쪽 4개의 두 부분을 병합
	1 2 3 4 5 6 7 8

[Pseudo Code]
If only one item
	Return
Else
	Sort left half of items
	Sort right half of items
	Merge sorted halves

왼쪽 절반을 정렬하고 오른쪽 절반을 정렬한 뒤 하나의 배열로 합치면 된다.
병합이란 두 배열 중에서 가장 작은 값을 꺼내 다른 배열의 가장 작은 값 다음에 두는 과정

무언가를 절반으로 계속 나눈다면 로그 함수로 표현할 수 있다.

n개가 있다고 하면 높이는 log n, 나눌 수 있는 횟수가 log n이기 때문
병합 정렬의 실행 시간의 상한은 O(n log n)
숫자들을 반으로 나누는데 O(log n)의 시간이 들고, 각 반으로 나눈 부분들을 다시 정렬해서 병합하는 데 각각 O(n)의 시간이 걸린다.
실행 시간의 하한도 Ω(n log n), 숫자들이 이미 정렬되었는지 여부에 관계 없이 나누고 병합하는 과정이 필요

병합 정렬의 장점 : 최악의 경우 훨씬 빠르다. n log n
병합 정렬의 단점 : 최선이 경우 시간을 낭비한다. n log n ( 버블 정렬은 최선의 경우 O(n) )

상한선을 개선하고 싶다면 하한선을 희생해야 할 수도 있다.
Theta (Θ) 
	어떤 알고리즘의 상한선과 하한선이 같을 떄 Theta 표기법을 사용한다.

병합 정렬은 Θ(n log n) : 맹목적으로 같은 알고리즘을 계속 반복.

#생각해보기
Q : 병합 정렬을 선택 정렬이나 버블 정렬과 비교했을 때 장점과 단점
A : 장점으로는 n이 커질수록 실행 시간이 훨씬 빠르다.
	단점으로는 메모리를 많이 사용한다.
