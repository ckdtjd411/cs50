5. 메모리

1) 메모리 주소
학습 목표 : 16진법을 읽고 쓸 수 있다.
		 메모리 주소에 접근하고 값을 받아오는 코드를 C로 작성할 수 있다.

#16진법
컴퓨터과학에서는 숫자를 10진수나 2진수 대신 16진수(Hexadecimal)로 표현하는 경우가 많다.
컴퓨터에서 데이터를 처리하기 위해 16진수를 사용할 때 장점이 있기 때문.

16진수를 사용하면 2진수를 간단하게 나타낼 수 있다.
RGB는 16진법으로 각 색의 양을 나타내도록 정한 것

#10진수를 16진수로 바꾸어보기
2진수로 모든 데이터를 표현하기에는 너무 길어지기 때문에 16진수를 사용
4bits를 사용하면 16진수로 표현할 수 있다.
알파벳을 사용하면 한지리로 0부터 9까지 뿐만 아니라 10, 11, ..., 15까지 셀 수 있다.
모호함을 없애기 위해서 16진수를 사용할 때는 0x를 붙이기로 약속

#16진수의 유용성
ASCILL 코드에 의해 "A, B, C"는 10진수로 65, 66, 67에 해당
컴퓨터는 10진수를 이해할 수 없으므로 2진수로 표현해 보면 "01000001 01000010 01000011"이 된다.
하지만 16진수로 표현하면 훨씬 간단해진다.
또한 컴퓨터는 8개의 비트가 모인 바이트 단위로 정보를 표현하기 때문에 2개의 16진수는 1byte의 2진수로 변환되기 때문에 정보표현에 유용하다.

#메모리 주소
int n = 50;
정수형 변수 n에 50이라는 값을 저장

int는 4바이트이기 때문에 컴퓨터의 메모리 어딘가에 변수 n이 4바이트의 크기로 저장되어 있다.
실제로는 50이 아닌 32bits로 구성된 0과 1이 50을 표현하고 있다. 

C에서는 변수의 메모리상 주소를 받기 위해 '&'이라는 연산자를 사용할 수 있다.
& : "~의 주소"를 의미하는 연산자
주소를 출력할 때 %p 형식지정자를 사용 (16진수로 출력)

컴퓨터 메모리 속 어디에 값이 저장되어 있는지 확인할 수 있다. 
그 값은 컴퓨터에 특정 값의 주소를 요구한 것으로 그 값을 가리키는 포인터 값을 돌려받는다.
포인터는 컴퓨터 메모리의 주소를 가리키는 것

반대로 '*'를 사용하면 그 메모리 주소에 있는 실제 값을 얻을 수 있다.
* : "~의 주소의 값"을 의미하는 연산자

#생각해보기
Q : 'CS50'을 16진수로 표현
A : C(43)
	S(53)
	50(32)
	0x43, 0x53, 0x32


2) 포인터
학습 목표 : 포인터 변수를 정의하고 사용할 수 있다.

#
'*' 연산자는 어떤 메모리 주소에 있는 값을 받아오게 해준다.
이 연산자를 이용해서 포인터 역할을 하는 변수를 선언할 수 있다.


만약 어떤 변수에 주소를 저장하고 싶다면 그 변수의 자료형뿐만 아니라 별 연산자 또한 써줘야 한다.

int n = 50;
int *p = &n;
*p라는 포인터 변수에 변수 n의 주소를 저장.
*는 이 변수가 포인터라는 의미이고, int는 이 포인터가 int 타입의 변수를 가리킨다는 의미

최근 컴퓨터는 보안상 문제로 메모리를 여기저기로 바꾸기 때문에 저장되는 주소가 달라진다.
주소를 저장하려고 하면 에러 -> 주소는 반드시 포인터에 저장해야 한다.

int n = 50;
int *p = &n;

p또한 변수기 때문에 bit로 데이터를 저장

포인터는 추상화를 위해 사용
실제로 p의 값, 즉 n의 주소값을 생각하지 않고, 추상적으로 단지 p가 n을 가리키고 있다는 것
따라서, 실제 주소는 신경 쓸 필요가 없어진다.

주소는 포인터 변수 p 안에 있지만 개념적으로는 이 변수가 다른 변수를 가리키는 것
포인터는 수많은 데이터를 관리하기 위해 사용하는 알고리즘의 기초가 된다.

#생각해보기
Q : 포인터의 크기는 메모리의 크기와 어떤 관계가 있을까?
A : 포인터는 주소 값을 저장하기 위한 자료형이다.
	따라서 메모리 주소 값을 저장할 수 있는 크기만큼의 공간이 필요하다.
	메모리의 크기가 커짐에 따라 표현할 수 있는 자료형의 크기가 커지면 포인터의 크기도 커져야 할 것이다.
	메모리의 주소를 표현하는 방식에 따라 포인터의 크기도 변한다.


3) 문자열
학습 목표 : 문자열 형태의 새로운 자료형인 string이 어떻게 정의되었는지 설명할 수 있다.

여태껏 문자열을 저장하기 위해 CS50 라이브러리에 포함된 string 자료형을 사용했다.
string s = "EMMA";
이는 메모리 속 5바이트의 공간에 E M M A \0

각 바이트는 고유의 주소를 갖고 있다.
문자열은 문자 하나하나가 계속 이어지는 형태, 문자의 배열이다.
'\0' 종단 문자를 통해 문자열의 끝을 표시한다.
문자열의 첫 번째 글자만 가리키면 널 종단 문자를 마주칠 때까지 루프를 돌면서 끝을 알아낸다.

변수 s는 결국 문자열을 가리키는 포인터이다.
문자열의 가장 첫번째 문자, 즉 s[0]를 가리키게 된다.
s가 EMMA의 이름의 시작인 E가 있는 위치를 가리키고 있다.
따라서 결국 문자열은 문자 배열의 첫 번째 바이트 주소를 뜻한다.

char *s = "EMMA";
*는 주소를 나타내고 char는 주소에 있는 값의 자료형이 char이라는 의미

typedef를 사용해 이름이나 숫자와 같은 다양한 변수를 하나로 묶어서 새로운 자료형을 선언
typedef char *string;	<- 실제 CS50 라이브러리에서 정의
char *문자에 대한 포인터를, string은 자료형의 이름을 의미

문자열은 여러 문자의 묶음을 추상화 한 것
s는 주소이다.

#생각해보기
Q : string 자료형을 정의해서 사용하면 어떤 장점이 있을까?
A : 프로그래머가 문자열임을 훨씬 직관적으로 이해하고 사용할 수 있다.


4) 문자열 비교
학습 목표 : 문자열이 저장되어 있는 방식에 근거해서 문자열을 비교하는 방법에 대해 설명할 수 있다.

char *s = "EMMA";
printf("%p\n", s);
s라는 포인터의 값, 즉 "EMMA"라는 문자열의 가장 첫 값인 "E"에 해당하는 메모리 주소를 출력

printf("%p\n", &s[0]);
printf("%p\n", &s[1]);
printf("%p\n", &s[2]);
printf("%p\n", &s[3]);
s가 가리키는 곳을 시작으로 각각 s라는 문자열의 n번째 문자에 해당하는 주소값을 출력

문자열은 첫번째 문자를 시작으로 메모리상에서 바로 옆에 저장되어 있다.
가장 첫 번째 문자에 해당하는 주소값을 하나씩 증가시키면 바로 옆에 있는 문자의 값을 출력할 수 있다.

printf("%c\n", *s);
printf("%c\n", *(s+1));
printf("%c\n", *(s+2));
printf("%c\n", *(s+3));

문법적 설탕(Syntctic sugar)
	사람이 이해하고 표현하기 쉽게 디자인된 프로그래밍 언어 문법
	더욱 더 간결하고 명확하게 표현이 가능한 문법을 뜻한다.

*s는 s의 주소로 가달라는 의미
s를 출력하면 한 글자가 아니라 전체 문자열을 출력?
이는 printf의 형식 지정자가 하는 역할, %s를 사용해서 출력을 요청하면 다음 문자를 계속 출력한다.
포인터 연산은 주소를 가져와서 계산을 하는 것

get_string으로 문자열을 입력받아 s라 하고 또 다른 문자열을 받아 t라 하면 메모리 두 덩어리를 얻는다.
사용자가 동일한 내용을 입력했을 수 있지만 같은 곳에 있다는 의미는 아니다.

문자열을 비교할 때 문자열이 저장된 변수를 바로 비교하게 되면 그 변수가 저장되어 있는 주소가 다르기 때문에 다르다는 결과가 출력
(비교한 것은 두 변수의 주소)
정확한 비교를 위해서는 실제 문자열이 저장되어 있는 곳으로 이동하여, 각 문자를 하나하나씩 비교해야 한다.

get_string을 호출할 때마다 메모리 어딘가에서 입력한 문자 크기만큼의 공간을 찾아 입력한 글자를 넣어둔다.
get_string 코드는 메모리 공간의 첫 바이트 주소를 반환하게 되어 있다.
즉, 호출될 때마다 포인터를 반환한다.

#생각해보기
Q : 문자열을 비교하는 코드는 어떻게 작성해야 할까?
A : 문자열의 첫 번째 위치로 이동하여 그 위치에 저장된 내용을 일일이 비교해야 한다.


5) 문자열 복사
학습 목표 : 문자열을 복사할 수 있다.

string s = get_string("s: ");
string t = s;

t[0] = toupper(t[0]);

printf("s: %s\n", s);
printf("t: %s\n", t);

사용자에게 입력값을 받아 string s에 저장하고 string t를 s로 정의한다.
t의 첫 번째 문자를 toupper 함수를 이용하여 대문자로 바꾼다면?
입력값으로 "emma"를 주게 된다면, s와 t 모두 "Emma'라고 출력이 된다.

그 이유는 s라는 변수에는 그 문자열이 있는 메모리의 주소가 저장되기 때문
string인 s와 t는 사실상 char *이기 떄문에 주소를 복사하고 있는 것
따라서 t도 s와 동일한 주소를 가리키고 있기 때문에 값을 수정하면 둘 다 반영된다.

문자열을 실제로 메모리상에서 복사하려면 메모리 할당 함수를 사용
문자열을 복사하는 데 필요한 메모리 공간을 할당받고 루프를 통해 복사

char *s = get_string("s: ");
char *t = malloc(strlen(s) + 1);

for (int i = 0, n = strlen(s); i < n + 1; i++)
{
    t[i] = s[i];
}

malloc 은 정해진 크기만큼 메모리를 할당하는 함수이다.
인자로 받는 것은 할당받을 메모리 크기
s 문자열의 길이에 널 종단 문자(\0)에 해당하는 1을 더한 만큼 메모리를 할당한다.
malloc은 할당한 메모리의 첫 바이트 주소를 반환
그리고 루프를 돌면서 s 문자열 배열에 있는 문자 하나하나를 t배열에 복사한다.

strlen을 사용하려면 string.h 헤더파일을 추가해야한다.

#생각해보기
Q : 메모리 할당을 통해 문자열을 복사하지 않고, 단순히 문자열의 주소만 복사했을 때는 어떤 문제가 생길까?
A : 초기 입력값을 가지고 연산 및 수정을 하게 된다면 기존의 입력값도 변화하므로 초기값이 상실된다.
	

6) 메모리 할당과 해제
학습 목표 : 메모리를 할당하고 해제할 수 있다.

메모리 할당이란 메모리 일부분을 가져와서 그곳을 가리키는 포인터를 주는 것
그 주소는 기억해야 하므로 포인터 변수에 저장한다.

malloc 함수를 이용하여 메모리를 할당한 후에는 free라는 함수를 이용하여 메모리를 해제해줘야 한다.
그렇지 않은 경우 메모리에 저장한 값은 쓰레기 값으로 남게 되어 메모리 용량의 낭비가 발생하기 때문
이러한 현상을 '메모리 누수'라고 한다.

사용하지 않는 메모리는 해제하는 것이 좋다.
그래야 프로그램이 더 많은 메모리를 사용할 수 있다. 

valgrind라는 프로그램을 사용하면 작성한 코드에서 메모리와 관련된 문제가 있는지를 쉽게 확인할 수 있다.
help50 valgrind ./filename
와 같은 명령어를 사용하면 filename 파일에 대한 valgrind의 검사 내용을 쉽게 확인할 수 있다.

void f(void)
{
    int *x = malloc(10 * sizeof(int));
    x[10] = 0;
}

int main(void)
{
    f();
    return 0;
}

f 함수를 보면 포인터 x에 int형의 사이즈(4바이트)에 10배에 해당하는 크기의 메모리,
즉 40바이트를 할당한다.
그리고 x의 10번째 값으로 0을 할당한다.

이를 valgrind로 검사해보면 버퍼 오버플로우와 메모리 누수 두 가지 에러를 확인할 수 있다.

x[10] = 0;
버퍼 오버플로우 
	할당하지 않은 메모리 영역을 접근하려고 할 때 발생

배열의 인덱스는 0부터 시작하므로 인덱스 10은 배열의 범위 밖이므로 버퍼 오버플로우가 발생
메모리 누수는 x라는 포인터를 통해 할당한 메모리를 해제하기 위해 free(x)를 추가함으로써 해결

#생각해보기
Q : 제한된 메모리를 가지고 프로그래밍을 할 때 메모리를 해제하지 않으면 어떤 문제가 발생할까?
A : 메모리에 저장되어 있지만 사용되지 않는 값들이 많아져서 정작 사용할 수 있는 메모리의 양이 줄어든다.
	이는 프로그램이 제 기능을 수행하지 못하게 한다.


7) 메모리 교환, 스택, 힙
학습 목표 : 메모리에 저장된 두 값을 교환하는 코드를 작성할 수 있다.

두 개의 변수를 교환하려면 임시 공간이 필요하다.

swap은 정수 a와 b를 입력받아 그 값을 바꾸는 일을 수행
void swap(int a, int b)
{
	int tmp = a;
	a = b;
	b = tmp;
}

swap을 호출해도 값은 전혀 바뀌지 않았다.
함수에 인자를 전달할 때 그 값을 복사해서 전달한다.
따라서 x와 y가 1과 2로 초기화되어 있고 함수에 인자로 전달하지만 함수는 x와 y의 복사본을 전달받는다.
a와 b는 각각 x와 y의 값을 복제하여 가지게 되므로 서로 다른 메모리 주소에 저장되는 것

컴퓨터는 메모리 속에서 아무 공간이나 사용하는 것이 아닌 자료형에 따라 저장되는 위치가 다르다.

machine code
globals
heap
  ↓
  
  ↑
stack

머신 코드 영역에는 프로그램이 실행될 때 그 프로그램이 컴파일된 바이너리가 저장
글로벌 영역에는 프로그램 안에서 저장된 전역 변수가 저장
힙 영역에는 malloc으로 할당된 메모리의 데이터가 저장
	메모리를 할당받을 수 있는 커다란 영역
	아래로 자라기 때문에 메모리를 사용할 수록 아래로 내려간다.
스택 영역에는 프로그램 내의 함수와 관련된 것들이 저장
	프로그램에서 어떤 함수를 호출할 때마다 함수의 지역변수들은 스택이라는 메모리 제일 아래 영역에 놓인다.

힙은 malloc이 메모리를 할당하는 곳, 스택은 함수가 호출될 때 지역 변수가 쌓이는 공간
스택 프레임 : 지역 변수를 저장하는 공간

a, b, x, y, tmp 모두 스택 영역에 저장되지만 a와 x, b와 y는 그 안에서도 서로 다른 위치에 저장된 변수이다.
따라서 a와 b를 바꾸는 것은 x와 y를 바꾸는 것에 아무런 영향X

void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

swap(&x, &y);  // x의 주소와 y의 주소

int *a는 정수의 주소를 받아 a라 부른다는 의미
a와 b 모두 정수를 가리키는 포인터
값을 전달하지 않고 주소를 전달해서 그 주소로 가서 값을 바꾸게 한다.

#생각해보기
Q : 메모리 영역을 다양하게 나누는 이유는 무엇일까?
A : 메모리 영역을 나누지 않으면 필요한 데이터를 찾기 위해서 전체 메모리를 탐색해야 한다.
	이는 비효율적인 작업이며 메모리 영역을 구분함으로써 자료형이 가진 특성에 따라 해당 위치에 쉽게 접근이 가능하다.


8) 파일 쓰기
학습 목표 : 사용자로부터 값을 입력받아 파일에 출력하는 프로그램을 작성할 수 있다.

두 메모리 영역이 어디선가 충돌
힙 영역에서는 malloc에 의해 메모리가 더 할당될수록 점점 사용하는 메모리의 범위가 어래로 늘어난다.
스택 영역에서도 함수가 더 많이 호출 될수록 사용하는 메모리의 범위가 점점 위로 늘어난다.
이렇게 늘어나다 보면 제한된 메모리 용량 하에서는 기존의 값을 침범하는 상황이 발생한다.
이를 힙 오버플로우 또는 스택 오버플로우라고 한다.

#사용자에게 입력 받기
scanf는 사용자로부터 형식 지정자에 해당되는 값을 입력받아 저장하는 함수이다.
형식 지정자를 쓰면 그 형식대로 입력을 받는다.

int x;
printf("x: ");
scanf("%i", &x);

&s로 그 주소를 입력하는 이유는 scanf 함수의 변수가 실제로 스택 영역 안에 s가 저장된 주소로 찾아가서
사용자가 입력한 값을 저장하도록 하기 위해서이다.

버퍼 오버플로우
	프로그램이 실행될 때 입력받는 값이 버퍼 이후의 공간을 침범하는 현상
	사용자가 버퍼보다 더 많은 양의 데이터를 입력할 때 발생

char *s = NULL;
주소를 미리 알 수 없으니 NULL을 사용
NULL은 특별한 포인터로 가리키는 곳이 없다는 뜻
NULL은 메모리 공간이 할당되지 않음

char s[5];
printf("s: ");
scanf("%s", s);

배열은 메모리가 연속적으로 할당된 공간이고 문자열은 문자가 연속적으로 있는 것
문자열은 그 메모리 공간 첫 번째 주소를 의미
이에 따라 포인터는 배열과 같다.

clang 컴파일러는 문자 배열의 이름을 포인터처럼 다룬다.
즉 scanf에 s라는 배열의 첫 바이트 주소를 넘겨주는 것

#파일 쓰기
FILE *file = fopen(filename, "a");

FILE이라는 자료형을 가리키는 포인터 변수 file
fopen 함수를 이용하면 파일을 FILE이라는 자료형으로 불러올 수 있다.
fopen은 해당 파일을 가리키는 포인터를 반환한다.

fopen는 첫 번쨰 인자는 파일의 이름, 두 번째 인자는 모드로 r(읽기), w(쓰기), a(덧붙이기)를 의미
fprintf 함수를 이용하여 파일에 직접 내용을 출력할 수 있다.
작업이 끝난 후에는 fclose함수로 파일에 대한 작업을 종료해주어야 한다.

csv파일 : 쉼표로 분리된 값으로 저장된 파일

#생각해보기
Q : get_long, get_float, get_char도 비슷한 방식으로 직접 구현할 수 있을까?
A : scanf에 각각에 해당하는 형식 지정자를 사용하면 구현할 수 있을 것
	scanf("%ld", &x); scanf("%f", &y); scanf("%c", &z);


9) 파일 읽기
학습 목표 : 파일을 읽고 JPEG 파일인지를 검사하는 프로그램을 작성할 수 있다.

#include <stdio.h>

int main(int argc, char *argv[])
{
	// Ensure user ran program with two words at prompt
    if (argc != 2)
    {
        return 1;
    }
	
	// Open file 
    FILE *file = fopen(argv[1], "r");
	
    if (file == NULL)
    {
        return 1;
    }

	// Read 3 bytes from file
    unsigned char bytes[3];
    fread(bytes, 3, 1, file);

	// Check if bytes are 0xff 0xd8 0xff
    if (bytes[0] == 0xff && bytes[1] == 0xd8 && bytes[2] == 0xff)
    {
        printf("Maybe\n");
    }
    else
    {
        printf("No\n");
    }
	
	// Close file
    fclose(file);
}

argc가 2가 아니라면, 파일명이 입력되지 않았거나 파일명 외의 다른 인자가 입력되었기 때문에 1(오류)를 리턴하고 종료
입력받은 파일명(argv[1])을 '읽기(r)' 모드로 불러온다.
만약 파일이 제대로 열리지 않으면 fopen 함수는 NULL을 리턴하기 때문에 이를 검사해서
FILE을 제대로 쓸 수 있는지를 검사하고, 아니라면 1(오류)를 리턴하고 프로그램을 종료

그 후 크기가 3인 문자 배열을 만들고, fread 함수를 이용해서 파일에서 첫 3바이트를 읽어온다.
fread 함수의 각 인자는 (배열, 읽을 바이트 수, 읽을 횟수, 읽을 파일)을 의미한다.

마지막으로 읽어들인 각 바이트가 각각 0xFF, 0xD8, 0xFF 인지를 확인
JPEG 형식의 파일을 정의할 때 만든 약속으로, JPEG 파일의 시작점에 꼭 포함되어 있어야 한다.
따라서 이를 검사하면 JPEG 파일인지를 확인할 수 있다.

#생각해보기
Q : JPEG 외에 다른 파일 형식도 그 형식임을 알려주는 약속이 있을까?
A : 참고) http://forensic-proof.com/archives/300
	파일이 담고 있는 데이터를 유용하게 사용하기 위해서는 관련된 소프트웨어가 필요
	이러한 소프트웨어들은 각각 자신만의 고유한 파일 포맷을 만들어 사용한다.
	파일 시그니처 : 포맷의 기본이 되는 내용
	모든 파일은 파일 시그니처를 갖는다.