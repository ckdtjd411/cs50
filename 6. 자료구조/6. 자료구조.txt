6. 자료구조

1) malloc과 포인터 복습
학습 목표 : 포인터의 개념과  malloc 함수의 용법을 잘 이해할 수 있다.

int main(void)
{
	int *x;		// x라는 정수형 포인터 변수를 생성
	int *y;
	
	x = malloc(sizeof(int));	// int 크기의 메모리를 할당하여 메모리 영역의 첫 주소를 반환
								// 변수 x를 선언하고 그 안에 메모리의 주소를 저장
	*x = 42;	// x에 저장된 주소로 가서 42를 저장
	*y = 13;
}

malloc이 할당해준 4byte 크기의 메모리에 가서 42의 값을 넣는다.

int *y; 해당 변수를 위한 공간을 할당하지 않았다.
		y는 포인터로만 선언되었을 뿐이지, 어디를 가리킬지에 대해서는 정의가 되지 않았다.

초기화 되지 않은 *y는 프로그램 어딘가를 임의로 가리키고 있을 수도 있다.
따라서 그 곳에 값을 저장하는 것이 오류를 발생시킬 수도 있는 것!
없거나 잘못된 주소에 접근하면 코드의 메모리 문제나 세그멘테이션 오류 발생

y =x; // y는 x가 가리키는 곳과 동일한 곳을 가리킴
따라서 *y = 13; 으로 저장하면 x가 가리키는 곳에도 동일하게 13으로 저장

포인터가 가리키는 것을 포인티라고 한다.

포인터가 가리키는 곳으로 가서 포인티에 값을 넣으려면 역참조 연산자가 필요
x에 대한 역참조를 하면 x가 기리키는 곳으로 가서 포인티에 접근해서 값을 저장한다.

#생각해보기
Q : 포인터를 초기화시키지 않고 값을 저장하면 어떤 오류가 발생할 수 있을까?
A : 다른 프로그램에서 사용중인 주소에 값을 저장하여 프로그램이 제 기능을 수행하지 못할 수 있다.


2) 배열의 크기 조정하기
학습 목표 : 배열의 크기를 조정하는 코드를 작성할 수 있다.

배열의 크기는 미리 지정해야 한다.
배열의 크기를 키우려면 현재 배열이 저장되어 있는 메모리 위치의 바로 옆에 일정 크기의 메모리를 덧붙이면 되겠지만,
실제로는 다른 데이터가 저장되어 있을 확률이 높다.
따라서 안전하게 새로운 공간에 큰 크기의 메모리를 다시 할당하고 기존 배열의 값들을 하나씩 옮겨줘야 한다.
이런 작업은 O(n), 즉 배열의 크기 n만큼의 실행 시간이 소요된다.
새로운 배열을 생성하고 값을 저장한 뒤 이전에 사용된 메모리를 버리거나 free

정수 크기의 3배만큼 malloc하면 3개의 정수에 맞는 메모리를 받을 수 있다.
포인터를 반환받아서 왼쪽에 있는 포인터 변수에 저장

포인터는 메모리의 주소이고 배열은 메모리 덩어리

malloc은 가끔 메모리를 다 써버릴 수 있는 문제가 있다.
컴퓨터에 메모리가 부족하다면 NULL이 반환된다.
메모리를 할당할 때마다 널이 반환되었는지 확인할 것

* 숫자를 직접 하드코딩 하지 않고 상수나 다른 변수를 사용하는 것이 좋다.

직접 메모리를 할당하거나 직접 값들을 옮기고 free를 할 필요가 없다.
malloc을 쓰는 대신 realloc을 사용
realloc, 메모리를 새로 할당

realloc은 이미 할당받은 기존 메모리 덩어리를 새롭게 가져오고 원래보다 크든 작든 새롭게 설정된 크기로 바꾸는 작업을 한다.
realloc이 기존 배열에서 새로운 배열로 데이터를 복사해주고 널인지 체크하고 새로운 값을 저장하기만 하면 된다.

list를 새로운 메모리 덩어리로 바꾸게 되면 기존의 덩어리는 컴퓨터 어딘가에 저장되어 있지만 가리키는 포인터는 아무것도 없게 된다.
임시 변수를 하나 만들어서 할당한 메모리를 놓치지 않도록 해야 하는 이유

#생각해보기
Q : 이미 할당된 메모리의 크기를 조절할 때 임시 메모리를 새로 할당해줘야 하는 이유
A : 배열의 크기를 수정하려면 배열의 선언부터 초기화까지 모두 수정해야한다.
	새로운 배열을 만들어 이동하는 방법도 있지만 이는 배열의 크기만큼의 이동을 반복해야 하므로 비효율적이다.
	따라서 임시 메모리를 새로 할당하여 값을 저장하면 위의 과정이 없이 간단하게 이동할 수 있다.


3) 연결 리스트: 도입
학습 목표 : 연결 리스트의 정의를 설명할 수 있다.

자료 구조는 컴퓨터 메모리에 정보를 각기 다른 방법으로 저장할 수 있도록 해준다.
데이터 구조는 컴퓨터 메모리를 더 효율적으로 관리하기 위해 새로 정의하는 구조체이다.
일종의 메모리 레이아웃, 또는 지도라고 생각할 수 있다.

struct 구조체, 자신만의 구조를 만들 수 있는 키워드
. : 구조체의 속성값을 가져올 때 사용
* : 메모리에 접근할 수 있는 역참조 연산자

배열에서는 각 인덱스의 값이 메모리상에서 연이어 저장되어 있다.
배열의 장점은 쉽게 인덱스에 접근할 수 있고 일정한 시간에 접근이 가능하다.
단점으로는 크기를 조절하려면 더 많은 메모리를 할당한 뒤 값들을 이동하는 작업이 필요하다.

각 값이 메모리상의 여러 군데 나뉘어져 있다고 하더라도 바로 다음 값의 메모리 주소만 기억하고 있다면 값을 연이어서 읽어들일 수 있다.
이를 '연결 리스트'라고 한다.
연결 리스트는 각 인덱스의 메모리 주소에서 자신의 값과 함께 바로 다음 값의 주소(포인터)를 저장한다.

마지막 리스트에는 리스트에 더 이상 남은 것이 없다는 것을 나타내기 위한 NULL을 다음 값의 주소로 저장
NULL은 문자 \0을 뜻하는 NULL과는 다르다. (NULL은 포인터, 하지만 둘 다 값은 0)

노드는 직사각형으로 나타낼 수 있는 메모리 덩어리를 의미
포인터는 node 구조체를 가리키도록 정의되어 있다.

typedef strcut node	// 구조체의 정식 명칭
{
    int number;			// 각 노드가 가지는 값
    struct node *next;	// 다음 node를 가리키는 포인터
}
node;	// 구조체의 별명

typedef struct 대신에 typedef struct node 라고 ‘node’를 함께 명시해 주는 것은, 구조체 안에서 node를 사용하기 위해
node 구조체에서 node로의 별칭을 제공하는 것. 
이는, 프로그램의 다른 부분에서 사용하기 쉽도록 해준다.

#생각해보기
Q : 연결 리스트를 배열과 비교했을 때 장단점은 무엇
A : 메모리를 새로 할당하지 않고 사용가능한 메모리를 사용하면 되므로 효율적이다.
	하지만 배열은 메모리에 연이어 있어 접근이 쉬우나 연결 리스트는 포인터를 통해 찾아가야 하는 불편함이 있다.


4) 연결 리스트: 코딩
학습 목표 : 연결 리스트를 구현하고 사용할 수 있다.

#include <stdio.h>
#include <stdlib.h>

//연결 리스트의 기본 단위가 되는 node 구조체를 정의
typedef struct node
{
    //node 안에서 정수형 값이 저장되는 변수를 number로 지정
    int number; 

    //다음 node의 주소를 가리키는 포인터를  *next로 지정
    struct node *next;
}
node;

int main(void)
{
    // list라는 이름의 node 포인터를 정의. 연결 리스트의 가장 첫 번째 node를 가리킨다.
    // 이 포인터는 현재 아무 것도 가리키고 있지 않기 때문에 NULL 로 초기화
    node *list = NULL;

    // 새로운 node를 위해 메모리를 할당하고 포인터 *n으로 가리킨다.
	// malloc을 할 때마다 반환된 값을 항상 체크
    node *n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number 필드에 1의 값을 저장합니다. “n->number”는 “(*n).numer”와 동일한 의미 
    // 즉, n이 가리키는 node의 number 필드를 의미 
    // 간단하게 화살표 표시 ‘->’로 쓸 수 있습니다. n의 number의 값을 1로 저장
    n->number = 1;

    // n 다음에 정의된 node가 없으므로 NULL로 초기화
    n->next = NULL;

    // 첫번째 node를 정의했기 떄문에 list 포인터를 n 포인터로 바꿔 준다.
    list = n;

    // list에 다른 node를 더 연결하기 위해 n에 새로운 메모리를 다시 할당
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    // n의 number와 next의 값을 각각 저장
    n->number = 2;
    n->next = NULL;

    // list가 가리키는 것은 첫 번째 node 
    //이 node의 다음 node를 n 포인터로 지정
    list->next = n;

    // 다시 한 번 n 포인터에 새로운 메모리를 할당하고 number과 next의 값을 저장
    n = malloc(sizeof(node));
    if (n == NULL)
    {
        return 1;
    }

    n->number = 3;
    n->next = NULL;

    // 현재 list는 첫번째 node를 가리키고, 이는 두번째 node와 연결되어 있다. 
    // 따라서 세 번째 node를 더 연결하기 위해 첫 번째 node (list)의 
    // 다음 node(list->next)의 다음 node(list->next->next)를 n 포인터로 지정
    list->next->next = n;

    // list에 연결된 node를 처음부터 방문하면서 각 number 값을 출력
    // 마지막 node의 next에는 NULL이 저장되어 있을 것이기 때문에 이것이 for 루프의 종료 조건
    for (node *tmp = list; tmp != NULL; tmp = tmp->next)
    {
        printf("%i\n", tmp->number);
    }

    // 메모리를 해제해주기 위해 list에 연결된 node들을 처음부터 방문하면서 free
    while (list != NULL)
    {
        node *tmp = list->next;
        free(list);
        list = tmp;
    }
}

#생각해보기
Q : 연결 리스트의 중간에 node를 추가하거나 삭제하는 코드는 어떻게 작성할 수 있을까
A : 
	삽입 : 노드가 삽입할 위치의 다음 노드를 가리키고 이전 노드가 삽입된 노드를 가리킨다.
    n = malloc(sizeof(node));
    if (n == NULL)
        return 1;
    
    n->number = 3;
    n->next = list->next->next;

    list->next->next = n;
	
	삭제 : 삭제할 이전 노드가 그 다음 노드를 가리키고 삭제할 노드는 free
	list->next->next = n->next;
    free(n);


5) 연결 리스트: 시연
학습 목표 : 연결 리스트와 배열의 장단점을 설명할 수 있다.

컴퓨터는 한 번에 하나의 메모리만 볼 수 있다.
연결 리스트에 있는 숫자들은 보이지 않고 모든 메모리를 하나씩 열어봐야 한다.
각각의 값을 찾기 위해서 최대한으로는 모든 위치를 탐색

리스트에 동적으로 추가하여 원하는 만큼 리스트를 크게 만들 수 있다.

연결 리스트
장점 : 배열처럼 숫자를 추가하기 위해서 크기를 조절하고 기존의 값을 모두 옮기지 않아도 된다.
	 새로운 값을 추가할 때 다시 메모리를 할당하지 않아도 된다.

단점 : 임의 접근을 할 수 없다. (이진 탐색을 할 수 없다.)
		이진 탐색은 O(log n), 연결리스트 탐색&삽입은 O(n)
	 리스트의 끝이나 중간을 찾기 위해서는 모든 화살표를 따라가야 한다.
	 리스트의 처음부터 끝까지 가기 위해서는 포인터를 따라가야하고 중간의 값으로 바로 갈 수는 없다.

#생각해보기
Q : 배열이 정렬되어 있지 않은 경우의 검색 소요 시간을 연결 리스트의 검색 시간과 비교
A : 정렬되어 있지 않은 배열에 대해 요소를 검색한다면 배열의 크기(n) 만큼의 시간이 소요된다.
	연결 리스트도 각각의 노드를 따라 이동하며 노드의 개수만큼 이동해야 하므로 O(n)


6) 연결 리스트: 트리
학습 목표 : 트리의 구조를 설명하고 활용하는 코드를 작성할 수 있다.

트리는 연결리스트를 기반으로 한 새로운 데이터 구조
연결리스트에서의 각 노드들의 연결이 1차원적으로 구성되어 있다면, 트리에서의 노드들의 연결은 2차원적으로 구성
각 노드는 일정한 층에 속하고 다음 층의 노드들을 가리키는 포인터를 가지게 된다.

가장 높은 층에서 트리가 시작되는 노드를 '루트'라고 한다.
루트 노드는 다음 층의 노드들을 가리키고 있고, 이를 '자식 노드'라고 한다.
두 개의 포인터를 가진 node

typedef struct node
{
	int number;
	struct node *right;	// 오른쪽 자식 노드
	struct node *left;	// 왼쪽 자식 노드
}
node;


이진 탐색 트리
각 노드는 일정한 규칙이 존재
하나의 노드는 두 개의 자식 노드를 가진다.
왼족 자식 노드는 자신의 값보다 작고, 오른쪽 자식 노드는 자신의 값보다 크다. (재귀적으로 정의)


트리의 노드들이 모두 최대 두 개의 자식 노드가 있고 이진법의 이진을 따와서 최대

장점 : 이진 탐색이 가능하다. O(log n)
	 포인터를 이용했기 때문에 역동적

메모리의 어디에 있건 간에 트리라고 불리는 자료 구조를 계속해서 저장해야 한다.
하나의 포인터가 이 루트라고 불리는 것을 가리켜야 한다.

트리의 높이는 밑이 2인 log

// 이진 탐색 함수 (*tree는 이진 탐색 트리를 가리키는 포인터)
bool search(node *tree)
{
	if (tree == NULL)
	{
		return false;
	}
	else if (50 < tree->number)
	{
		return search(tree->left);
	}
	else if (50 > tree->number)
	{
		return search(tree->right);
	}
	else
	{
		return true;
	}
}

이진 검색 트리를 활용하였을 때 검색 실행 시간과 노드 삽입 시간은 모두 O(log n)

#생각해보기
Q : 값을 검색할 때 이진 검색 트리가 기본 연결 리스트에 비해 가지는 장점과 단점은?
A : 기본 연결리스트는 모든 노드를 이동하며 값을 탐색하지만 이진 검색 트리는 절반의 경우로 나누어 검색하므로 시간이 더 빠르다.
	자식 노드가 있는 노드를 삭제한다고 할 때 노드의 이동과 여러 포인터 값들을 수정해야 한다.


7) 해시 테이블
학습 목표 : 해시 테이블의 원리와 구조를 설명할 수 있다.

해시 테이블은 '연결 리스트의 배열'
여러 값들을 몇 개의 바구니에 나눠 담는 상황을 생각해 보자.
각 값들은 '해시 함수'라는 맞춤형 함수를 통해서 어떤 바구니에 담기는 지 결정된다.
이와 같이 연결 리스트가 담긴 바구니가 여러개 있는 것이 '연결 리스트의 배열', 즉 '해시 테이블'이 된다.

어떤 값을 넣으려고 하는데 이미 무언가 들어 있는 경우 어떤 방법으로든 해결해야 한다.

해시 함수는 '이름의 가장 첫 글자'인 경우를 생각해보자.
그 경우 알파벳 개수에 해당하는 총 26개의 포인터들이 있을 수 있으며, 
각 포인터는 그 알파벳을 시작으로 하는 이름들을 저장하는 연결 리스트를 가리키게 된다.

만약 해시 함수가 이상적이라면, 각 바구니에는 단 하나의 값들만 담기게 된다.
따라서 검색 시간은 O(1)
하지만 그렇지 않은 경우, 최악의 상황에는 단 하나의 바구니에 모든 값들이 담겨서 O(n)이 될 수도 있다.

이름 첫 글자만 보지 않고 첫 두글자를 살펴본다면?
공간은 더 많이 필요하지만 충돌할 확률은 낮아진다.
그러나 여전히 충돌 문제가 발생한다.

그렇기 때문에 시간과 공간 사이에 균형이 필요하다.
각각 다른 결과를 가져서 충돌이 서로 일어나지 않도록 하는 알고리즘을 구현한다면 O(1)의 실행 시간을 가진다.
얼마나 많은 공간을 사용할 것인지 이상적인 해시 함수를 찾기 위해 얼마나 많은 노력을 기울일 것인지

#생각해보기
Q : 해시 함수는 어떻게 만들 수 있을까?
A : 


8) 트라이
학습 목표 : 트라이의 원리와 구조를 설명할 수 있다.

'트라이'는 기본적으로 '트리'형태의 자료 구조
각각의 노드가 '배열'로 이루어진 트리

어떤 자원을 절약하기 위해 다른 자원을 소비하는 패턴을 가진다.
트라이는 많은 메모리가 들지만 자료 구조 안의 데이터를 검색하는데 일정한 실행 시간을 가진다.

알파벳으로 이루어진 문자열 값을 저장한다고 한다면 이 노드는 a부터 까지의 값을 가지는 배열이 된다.
배열의 각 요소, 즉 알파벳은 다음 층의 노드(a-z 배열)을 가리킨다.
루트 노드를 시작으로 각 화살표가 가리키 알파벳을 따라가면서 노드를 이어준다.
위와 같은 트라이에서 값을 검색하는데 걸리는 시간은 '문자열의 길이'에 의해 한정된다.
일반적인 영어 이름의 길이를 n이라고 했을 때, 검색 시간은 O(n)이 되지만, 대부분의 이름은 그리 크지 않은
상수값이기 때문에 O(1)이나 마찬가지이다.

고정된 값이 있을 경우 상수라고 부른다.
상수 시간의 실행 시간을 제공하기 위해 아주 많은 양의 메모리를 사용

#생각해보기
Q : 트라이가 해시 테이블에 의해 가지는 장점과 단점은?
A : 장점으로는 항상 일정한 검색 시간을 제공한다.
	하지만 아주 많은 메모리를 사용하여 메모리를 효율적으로 사용하지 못한다.


9) 스택, 큐, 딕셔너리
학습 목표 : 스택, 큐, 딕셔너리의 원리와 구조를 설명할 수 있다.

#큐
큐는 메모리 구조에서 값이 아래로 쌓이는 구조
FIFO(First In First Out), 선입 선출의 특징을 가진 자료 구조
은행에서 줄을 설 때 가장 먼저 줄을 선 사람이 가장 먼저 업무를 처리하게 되는 것과 동일
먼저 요청을 보낸 순서대로 처리

두 가지 기본 연산
enqueue 줄에 들어가서 서는 것
dequeue 줄을 빠져나오는 것

배열이나 연결리스트를 이용

#스택
스택은 메모리 구조에서 값이 위로 쌓이는 구조
LIFO (Last In First Out), 후입 선출의 특징을 가진 자료 구조
접시를 쌓아 뒀을 때 가장 위에 있는 접시를 먼저 들고 가는 것과 동일

두 가지 기본 연산
push 스택에 어떤 요소를 밀어 넣는다
pop 가장 위의 요소를 뺀다

배열이나 연결 리스트를 이용

#딕셔너리
해시 테이블이라고도 생각할 수 있는 개념
딕셔너리는 '키'와 '값'이라는 요소로 이루어져 있다.
